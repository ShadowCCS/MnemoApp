We need to implement a modular, production-ready theme system that layers on top of Avalonia’s default FluentTheme, which provides base styles and templates for controls such as lists, buttons, inputs, etc.

Theme Storage:
Core Themes
Location: UI/Themes/Core/[ThemeName]/
Structure:

theme.axaml        # Contains brush/color definitions
manifest.json      # Metadata: name, author, version, previewColors, etc.
These themes are embedded (read-only) and bundled with the application.

User/Installed Themes
Location: Data/Themes/[ThemeName]/
These themes are downloaded or user-created and are stored on disk.

Theme Service
We need a centralized ThemeService class to manage all theme-related operations. This service should be exposed via the MnemoAPI:

MnemoAPI.ui.themes.getTheme("Dawn")
MnemoAPI.ui.themes.setTheme("MidnightSun")
MnemoAPI.ui.themes.getAllThemes() // both core + custom
At runtime, the service will scan:

var coreThemes = ScanFolder("avares://MnemoApp/UI/Themes/Core/");
var customThemes = ScanFolder(Path.Combine(AppPaths.DataDirectory, "Themes"));
Each scan returns a list of ThemeManifest objects with info like:

{
  "name": "Dawn",
  "author": "Mnemo",
  "version": "1.0.0",
  "previewColors": ["#DDDDDD", "#F1A120", "#222222"]
}

When calling setTheme(name), the system should:

Locate the theme (core or custom)

Load its theme.axaml

Replace the current merged dictionary

Trigger a UI refresh (dynamic via {DynamicResource} bindings)

Save the selected theme to:
Data/Portable/settings.json

On startup, the application should read this value and load the stored theme automatically.

MnemoAPI Integration
The service will expose a subset of functions under:

MnemoAPI.ui.themes.*

Example API functions:

getAllThemes() → returns manifest objects for all themes

getTheme("Dawn") → returns full manifest and optionally parsed resources

setTheme("MidnightSun") → swaps the current theme

getCurrentTheme() → returns currently active theme metadata

UI Implementation Requirements
All UI elements must bind to theme keys using {DynamicResource}:

Background="{DynamicResource Sidebar.Background}"
Foreground="{DynamicResource Button.Primary.Text}"
This ensures smooth runtime updates and modular theming.

Dynamic Refresh
When switching themes, we must ensure the entire UI refreshes without requiring a restart.

This means theme styles must be loaded via StyleInclude and inserted into Application.Current.Resources.MergedDictionaries.

Example:
var theme = new StyleInclude(...) { Source = ... };
Application.Current.Resources.MergedDictionaries.Clear();
Application.Current.Resources.MergedDictionaries.Add(theme);
